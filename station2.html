<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Û²: Ø§ØªØ§Ù‚ Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ</title>
    <style>
        :root {
            --foil-silver: #90A4AE; /* Ø±Ù†Ú¯ ÙÙˆÛŒÙ„ Ø¢Ù„ÙˆÙ…ÛŒÙ†ÛŒÙˆÙ…ÛŒ */
            --paper-craft: #D7CCC8; /* Ø±Ù†Ú¯ Ú©Ø§ØºØ° Ú©Ø±Ø§ÙØª */
            --gold: #FFC107;
            --blue-accent: #1976D2;
            --bg-factory: #ECEFF1;
            --success: #4CAF50;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-factory);
            color: #37474F;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: #263238;
            border-bottom: 3px solid var(--blue-accent);
            padding-bottom: 10px;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1000px;
            width: 100%;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .controls-panel {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border-left: 2px dashed #B0BEC5;
        }

        .visual-panel {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #FAFAFA;
            border-radius: 10px;
            padding: 10px;
            position: relative;
        }

        canvas {
            border: 1px solid #ddd;
            background: white;
            border-radius: 8px;
            cursor: crosshair;
        }

        .input-group { margin-bottom: 20px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; }
        select, input[type="range"] { width: 100%; padding: 8px; border-radius: 5px; border: 1px solid #ccc; }

        .btn-toggle {
            background: var(--blue-accent);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1em;
            margin-bottom: 10px;
            transition: 0.3s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
        }
        .btn-toggle:hover { transform: scale(1.05); }
        .btn-toggle.active { background: #E91E63; } /* ØªØºÛŒÛŒØ± Ø±Ù†Ú¯ ÙˆÙ‚ØªÛŒ Ø¨Ø§Ø² Ù…ÛŒâ€ŒØ´ÙˆØ¯ */

        .cost-box {
            background: #263238;
            color: var(--gold);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: center;
        }

        .budget-target {
            background: #FFF8E1;
            border: 2px solid var(--gold);
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: center;
        }

        .formula-display {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.2em;
            color: #555;
            margin-top: 5px;
            direction: ltr; /* ÙØ±Ù…ÙˆÙ„â€ŒÙ‡Ø§ Ú†Ù¾ Ø¨Ù‡ Ø±Ø§Ø³Øª Ø¨Ø§Ø´Ù†Ø¯ */
        }

        .status-msg { font-weight: bold; margin-top: 10px; min-height: 25px; }
        .success-text { color: var(--success); animation: blink 1s infinite; }

        @keyframes blink { 50% { opacity: 0.5; } }

        /* Ø§Ø³ØªØ§ÛŒÙ„ Ù…ÙˆØ¯Ø§Ù„ */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            z-index: 999;
        }
        .modal-box {
            background: white; padding: 30px; border-radius: 15px;
            text-align: center; max-width: 500px; border-top: 5px solid var(--blue-accent);
        }
        .hidden { display: none; }

    </style>
</head>
<body>

    <div id="introModal" class="modal">
        <div class="modal-box">
            <h2>ğŸ“¦ Ø¨Ù‡ Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!</h2>
            <p>Ø´Ú©Ù„Ø§Øªâ€ŒÙ‡Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯Ù‡â€ŒØ§Ù†Ø¯. Ø­Ø§Ù„Ø§ Ø¨Ø§ÛŒØ¯ Ø¢Ù†â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ú©Ù†ÛŒÙ….</p>
            <p>Ú©Ø§ØºØ° Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ú¯Ø±Ø§Ù† Ø§Ø³Øª! (Ù‚ÛŒÙ…Øª: Ù…ØªØ±ÛŒ Û±Û° ØªÙˆÙ…Ø§Ù†)</p>
            <p><strong>Ù…Ø§Ù…ÙˆØ±ÛŒØª:</strong> Ø§Ø¨Ø¹Ø§Ø¯ Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø±Ø§ Ø·ÙˆØ±ÛŒ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯ Ú©Ù‡ Ù‡Ø²ÛŒÙ†Ù‡ Ù†Ù‡Ø§ÛŒÛŒ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ Ø¨ÙˆØ¯Ø¬Ù‡â€ŒØ§ÛŒ Ø¨Ø§Ø´Ø¯ Ú©Ù‡ Ø­Ø³Ø§Ø¨Ø¯Ø§Ø±ÛŒ Ø¨Ù‡ Ù…Ø§ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯.</p>
            <button class="btn-toggle" onclick="startGame()">Ø´Ø±ÙˆØ¹ Ú©Ø§Ø±</button>
        </div>
    </div>

    <h1>âœ‚ï¸ Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Û²: Ø§ØªØ§Ù‚ Ø¨Ø³ØªÙ‡â€ŒØ¨Ù†Ø¯ÛŒ (Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø³Ø§Ø­Øª)</h1>

    <div class="container" id="mainContainer">
        
        <div class="visual-panel">
            <button class="btn-toggle" id="viewToggle" onclick="toggleView()">ğŸ“‚ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¬Ø¹Ø¨Ù‡ (Unfold)</button>
            <canvas id="paperCanvas" width="350" height="350"></canvas>
            
            <div class="cost-box">
                <div>Ù‡Ø²ÛŒÙ†Ù‡ Ú©Ø§ØºØ° Ø§ÛŒÙ† Ø¨Ø³ØªÙ‡:</div>
                <div style="font-size: 2em; font-weight: bold;">
                    <span id="currentCost">0</span> ØªÙˆÙ…Ø§Ù†
                </div>
                <div id="areaDisplay" style="font-size: 0.9em; opacity: 0.8;">Ù…Ø³Ø§Ø­Øª: 0 cmÂ²</div>
                <div class="formula-display" id="formulaText">S = 6aÂ²</div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="input-group">
                <label>Ù†ÙˆØ¹ Ø´Ú©Ù„Ø§Øª:</label>
                <select id="shapeSelect" onchange="changeShape()">
                    <option value="cube">Ù…Ú©Ø¹Ø¨ (Cube)</option>
                    <option value="rectPrism">Ù…Ú©Ø¹Ø¨ Ù…Ø³ØªØ·ÛŒÙ„ (Prism)</option>
                    <option value="cylinder">Ø§Ø³ØªÙˆØ§Ù†Ù‡ (Cylinder)</option>
                </select>
            </div>

            <div id="slidersContainer">
                </div>

            <div class="budget-target">
                <h3>ğŸ’° Ø¨ÙˆØ¯Ø¬Ù‡ Ù…Ø¬Ø§Ø² (Ù‡Ø¯Ù):</h3>
                <div style="font-size: 1.8em; font-weight: bold; color: #333;">
                    <span id="targetCost">0</span> ØªÙˆÙ…Ø§Ù†
                </div>
                <div id="statusMsg" class="status-msg">ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯...</div>
                <button onclick="generateTarget(true)" style="margin-top:10px; cursor:pointer; padding: 5px 10px;">ğŸ”„ Ø³ÙØ§Ø±Ø´ Ø¬Ø¯ÛŒØ¯</button>
            </div>
            
            <p style="font-size: 0.8em; color: #777; margin-top: 20px;">
                * Ù‚ÛŒÙ…Øª Ù‡Ø± Ø³Ø§Ù†ØªÛŒâ€ŒÙ…ØªØ± Ù…Ø±Ø¨Ø¹ Ú©Ø§ØºØ°: <span id="paperPrice">10</span> ØªÙˆÙ…Ø§Ù†
            </p>
        </div>

    </div>
    <script>
        // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø§ØµÙ„ÛŒ
        const PAPER_PRICE = 10; // Ù‚ÛŒÙ…Øª Ù‡Ø± ÙˆØ§Ø­Ø¯ Ù…Ø³Ø§Ø­Øª
        const canvas = document.getElementById('paperCanvas');
        const ctx = canvas.getContext('2d');
        const PIXEL_SCALE = 12; // Ù…Ù‚ÛŒØ§Ø³ Ø±Ø³Ù…

        const state = {
            shape: 'cube',
            dims: { l: 4, w: 4, h: 4, r: 3 },
            isUnfolded: false, // Ø­Ø§Ù„Øª Ø¨Ø§Ø² ÛŒØ§ Ø¨Ø³ØªÙ‡
            targetCost: 0,
            limits: { 
                cube: { min: 1, max: 8 },
                rect: { min: 1, max: 8 },
                cyl_r: { min: 1, max: 5 },
                cyl_h: { min: 1, max: 8 }
            }
        };

        function startGame() {
            document.getElementById('introModal').classList.add('hidden');
            init();
        }

        function init() {
            changeShape();
        }

        function toggleView() {
            state.isUnfolded = !state.isUnfolded;
            const btn = document.getElementById('viewToggle');
            if(state.isUnfolded) {
                btn.innerText = "ğŸ“¦ Ø¨Ø³ØªÙ† Ø¬Ø¹Ø¨Ù‡ (Fold)";
                btn.classList.add('active');
            } else {
                btn.innerText = "ğŸ“‚ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¬Ø¹Ø¨Ù‡ (Unfold)";
                btn.classList.remove('active');
            }
            draw();
        }

        // --- Ù…Ù†Ø·Ù‚ Ø±ÛŒØ§Ø¶ÛŒ ---

        function getRandomVal(min, max) {
            // Ø§Ø¹Ø¯Ø§Ø¯ ØµØ­ÛŒØ­ Ø¨Ø±Ø§ÛŒ Ø±Ø§Ø­ØªÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù‡Ø²ÛŒÙ†Ù‡
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function calculateArea(dims, shape) {
            let area = 0;
            if (shape === 'cube') {
                area = 6 * dims.l * dims.l;
            } else if (shape === 'rectPrism') {
                // 2(lw + lh + wh)
                area = 2 * ( (dims.l * dims.w) + (dims.l * dims.h) + (dims.w * dims.h) );
            } else if (shape === 'cylinder') {
                // 2*pi*r*h (Ø¬Ø§Ù†Ø¨ÛŒ) + 2*pi*r^2 (Ø¯Ùˆ Ù‚Ø§Ø¹Ø¯Ù‡)
                area = (2 * Math.PI * dims.r * dims.h) + (2 * Math.PI * Math.pow(dims.r, 2));
            }
            return area;
        }

        function generateTarget(reset = false) {
            let fakeDims = {};
            // ØªÙˆÙ„ÛŒØ¯ Ø§Ø¨Ø¹Ø§Ø¯ Ø±Ù†Ø¯ÙˆÙ… ØµØ­ÛŒØ­ Ø¨Ø±Ø§ÛŒ Ù‡Ø¯Ù
            if (state.shape === 'cube') {
                const l = getRandomVal(state.limits.cube.min, state.limits.cube.max);
                fakeDims = { l: l };
            } else if (state.shape === 'rectPrism') {
                fakeDims = {
                    l: getRandomVal(state.limits.rect.min, state.limits.rect.max),
                    w: getRandomVal(state.limits.rect.min, state.limits.rect.max),
                    h: getRandomVal(state.limits.rect.min, state.limits.rect.max)
                };
            } else if (state.shape === 'cylinder') {
                fakeDims = {
                    r: getRandomVal(state.limits.cyl_r.min, state.limits.cyl_r.max),
                    h: getRandomVal(state.limits.cyl_h.min, state.limits.cyl_h.max)
                };
            }

            const area = calculateArea(fakeDims, state.shape);
            const cost = Math.floor(area * PAPER_PRICE); // Ø±Ù†Ø¯ Ú©Ø±Ø¯Ù† Ù‡Ø²ÛŒÙ†Ù‡ Ù†Ù‡Ø§ÛŒÛŒ
            state.targetCost = cost;

            document.getElementById('targetCost').innerText = cost.toLocaleString();

            if(reset) {
                state.dims = { l: 2, w: 2, h: 2, r: 2 };
                updateUI();
            }
            checkSuccess();
        }

        function updateUI() {
            // Ø¢Ù¾Ø¯ÛŒØª Ø§Ø³Ù„Ø§ÛŒØ¯Ø±Ù‡Ø§
            const inputs = document.querySelectorAll('#slidersContainer input');
            inputs.forEach(input => {
                const param = input.getAttribute('data-param');
                if(state.dims[param]) {
                    input.value = state.dims[param];
                    document.getElementById(`val-${param}`).innerText = state.dims[param];
                }
            });
            updateCalculations();
        }

        function updateCalculations() {
            const area = calculateArea(state.dims, state.shape);
            const cost = Math.floor(area * PAPER_PRICE);

            // Ù†Ù…Ø§ÛŒØ´
            document.getElementById('areaDisplay').innerText = `Ù…Ø³Ø§Ø­Øª Ú©Ù„: ${area.toFixed(1)} cmÂ²`;
            document.getElementById('currentCost').innerText = cost.toLocaleString();
            
            checkSuccess(cost);
            draw();
        }

        function checkSuccess(currentCost) {
            const diff = Math.abs(currentCost - state.targetCost);
            const msg = document.getElementById('statusMsg');
            const targetBox = document.querySelector('.budget-target');

            // ØªÙ„ÙˆØ±Ø§Ù†Ø³ Ù‡Ø²ÛŒÙ†Ù‡ (Ù…Ø«Ù„Ø§Ù‹ ÛµÛ° ØªÙˆÙ…Ø§Ù† Ø®Ø·Ø§ Ù…Ø¬Ø§Ø² Ø§Ø³Øª Ø¨Ù‡ Ø®Ø§Ø·Ø± Ú¯Ø±Ø¯ Ú©Ø±Ø¯Ù† Ù¾ÛŒ)
            const tolerance = (state.shape === 'cylinder') ? 50 : 0;

            if (diff <= tolerance) {
                msg.innerHTML = "âœ… Ø¹Ø§Ù„ÛŒ! Ø¨ÙˆØ¯Ø¬Ù‡ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø±Ø¹Ø§ÛŒØª Ø´Ø¯.";
                msg.className = "status-msg success-text";
                targetBox.style.borderColor = "green";
            } else {
                if (currentCost > state.targetCost) msg.innerText = "Ù‡Ø²ÛŒÙ†Ù‡ Ø²ÛŒØ§Ø¯ Ø´Ø¯! Ú©Ø§ØºØ° Ú©Ù…ØªØ±ÛŒ Ù…ØµØ±Ù Ú©Ù† ğŸ“‰";
                else msg.innerText = "Ù‡Ø²ÛŒÙ†Ù‡ Ú©Ù… Ø§Ø³Øª! Ø¨Ø³ØªÙ‡ Ø¨Ø§ÛŒØ¯ Ø¨Ø²Ø±Ú¯ØªØ± Ø¨Ø§Ø´Ø¯ ğŸ“ˆ";
                msg.className = "status-msg";
                targetBox.style.borderColor = "var(--gold)";
            }
        }

        // --- Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ ---

        function changeShape() {
            state.shape = document.getElementById('shapeSelect').value;
            const container = document.getElementById('slidersContainer');
            container.innerHTML = '';
            const formula = document.getElementById('formulaText');

            if (state.shape === 'cube') {
                createSlider(container, 'Ø·ÙˆÙ„ Ø¶Ù„Ø¹ (a)', 'l', state.limits.cube.min, state.limits.cube.max);
                formula.innerHTML = "Cost = (6 Ã— aÂ²) Ã— 10";
            } else if (state.shape === 'rectPrism') {
                createSlider(container, 'Ø·ÙˆÙ„ (l)', 'l', state.limits.rect.min, state.limits.rect.max);
                createSlider(container, 'Ø¹Ø±Ø¶ (w)', 'w', state.limits.rect.min, state.limits.rect.max);
                createSlider(container, 'Ø§Ø±ØªÙØ§Ø¹ (h)', 'h', state.limits.rect.min, state.limits.rect.max);
                formula.innerHTML = "Cost = 2(lw + lh + wh) Ã— 10";
            } else if (state.shape === 'cylinder') {
                createSlider(container, 'Ø´Ø¹Ø§Ø¹ (r)', 'r', state.limits.cyl_r.min, state.limits.cyl_r.max);
                createSlider(container, 'Ø§Ø±ØªÙØ§Ø¹ (h)', 'h', state.limits.cyl_h.min, state.limits.cyl_h.max);
                formula.innerHTML = "Cost = (2Ï€rh + 2Ï€rÂ²) Ã— 10";
            }
            
            state.isUnfolded = false;
            document.getElementById('viewToggle').innerText = "ğŸ“‚ Ø¨Ø§Ø² Ú©Ø±Ø¯Ù† Ø¬Ø¹Ø¨Ù‡ (Unfold)";
            document.getElementById('viewToggle').classList.remove('active');

            generateTarget();
            updateUI(); // Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
        }

        function createSlider(parent, label, param, min, max) {
            const div = document.createElement('div');
            div.className = 'input-group';
            div.innerHTML = `
                <label>${label} <span style="float:left; color:#1976D2" id="val-${param}">${state.dims[param] || min}</span></label>
                <input type="range" min="${min}" max="${max}" step="1" value="${state.dims[param] || min}" 
                    data-param="${param}" oninput="onSliderChange('${param}', this.value)">
            `;
            parent.appendChild(div);
        }

        function onSliderChange(param, val) {
            state.dims[param] = parseFloat(val);
            document.getElementById(`val-${param}`).innerText = val;
            updateCalculations();
        }

        // --- Ø¨Ø®Ø´ Ú¯Ø±Ø§ÙÛŒÚ© Ùˆ Ø±Ø³Ù… (Canvas) ---

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;

            if (state.isUnfolded) {
                drawUnfolded(cx, cy);
            } else {
                draw3D(cx, cy);
            }
        }

        function draw3D(cx, cy) {
            ctx.save();
            ctx.strokeStyle = '#37474F';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#CFD8DC'; // Ø±Ù†Ú¯ Ø¨Ø³ØªÙ‡ Ø¨Ø³ØªÙ‡ Ø´Ø¯Ù‡
            
            const { l, w, h, r } = state.dims;
            // Ú©Ù…ÛŒ Ù¾Ø§ÛŒÛŒÙ† Ù…ÛŒØ§Ø±ÛŒÙ… Ú©Ù‡ ÙˆØ³Ø· Ø¨Ø§Ø´Ù‡
            const centerY = cy + 50; 

            if (state.shape === 'cube' || state.shape === 'rectPrism') {
                let sl = (state.shape === 'cube' ? l : l) * PIXEL_SCALE;
                let sw = (state.shape === 'cube' ? l : w) * PIXEL_SCALE;
                let sh = (state.shape === 'cube' ? l : h) * PIXEL_SCALE;

                // Ø±Ø³Ù… Ù…Ú©Ø¹Ø¨ Ø§ÛŒØ²ÙˆÙ…ØªØ±ÛŒÚ© (Ù…Ø´Ø§Ø¨Ù‡ Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ 1)
                ctx.beginPath();
                ctx.moveTo(cx - sl/2, centerY);
                ctx.lineTo(cx + sl/2, centerY);
                ctx.lineTo(cx + sl/2, centerY - sh);
                ctx.lineTo(cx - sl/2, centerY - sh);
                ctx.closePath();
                ctx.fill(); ctx.stroke(); // Ø¬Ù„Ùˆ

                ctx.beginPath();
                ctx.moveTo(cx - sl/2, centerY - sh);
                ctx.lineTo(cx + sl/2, centerY - sh);
                ctx.lineTo(cx + sl/2 + sw/2, centerY - sh - sw/2);
                ctx.lineTo(cx - sl/2 + sw/2, centerY - sh - sw/2);
                ctx.closePath();
                ctx.fillStyle = '#B0BEC5'; ctx.fill(); ctx.stroke(); // Ø¨Ø§Ù„Ø§

                ctx.beginPath();
                ctx.moveTo(cx + sl/2, centerY);
                ctx.lineTo(cx + sl/2 + sw/2, centerY - sw/2);
                ctx.lineTo(cx + sl/2 + sw/2, centerY - sh - sw/2);
                ctx.lineTo(cx + sl/2, centerY - sh);
                ctx.closePath();
                ctx.fillStyle = '#90A4AE'; ctx.fill(); ctx.stroke(); // Ù¾Ù‡Ù„Ùˆ

            } else if (state.shape === 'cylinder') {
                let sr = r * PIXEL_SCALE;
                let sh = h * PIXEL_SCALE;
                
                // Ø¨Ø§Ù„Ø§ÛŒ Ø§Ø³ØªÙˆØ§Ù†Ù‡
                ctx.beginPath();
                ctx.ellipse(cx, centerY - sh, sr, sr * 0.4, 0, 0, 2 * Math.PI);
                ctx.fillStyle = '#B0BEC5'; ctx.fill(); ctx.stroke();

                // Ø¨Ø¯Ù†Ù‡
                ctx.beginPath();
                ctx.moveTo(cx - sr, centerY - sh);
                ctx.lineTo(cx - sr, centerY); // Ú†Ù¾
                ctx.ellipse(cx, centerY, sr, sr * 0.4, 0, Math.PI, 0, true); // Ú©Ù…Ø§Ù† Ù¾Ø§ÛŒÛŒÙ†
                ctx.lineTo(cx + sr, centerY - sh); // Ø±Ø§Ø³Øª
                ctx.fillStyle = '#CFD8DC'; ctx.fill();
                
                // Ø®Ø·ÙˆØ· Ø¹Ù…ÙˆØ¯ÛŒ Ø¨Ø¯Ù†Ù‡
                ctx.beginPath(); ctx.moveTo(cx - sr, centerY - sh); ctx.lineTo(cx - sr, centerY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx + sr, centerY - sh); ctx.lineTo(cx + sr, centerY); ctx.stroke();
                
                // Ø®Ø· Ù¾Ø§ÛŒÛŒÙ†
                ctx.beginPath();
                ctx.ellipse(cx, centerY, sr, sr * 0.4, 0, 0, Math.PI);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawUnfolded(cx, cy) {
            ctx.save();
            ctx.strokeStyle = '#E91E63'; // Ø±Ù†Ú¯ Ø®Ø· Ø¨Ø±Ø´
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]); // Ø®Ø· Ú†ÛŒÙ† Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒ Ú©Ø§ØºØ°
            ctx.fillStyle = '#F8BBD0'; // Ø±Ù†Ú¯ Ú©Ø§ØºØ° Ø¨Ø§Ø² Ø´Ø¯Ù‡

            const { l, w, h, r } = state.dims;
            
            if (state.shape === 'cube' || state.shape === 'rectPrism') {
                // Ø±Ø³Ù… Ú¯Ø³ØªØ±Ø¯Ù‡ Ù…Ú©Ø¹Ø¨ (Ø´Ú©Ù„ ØµÙ„ÛŒØ¨)
                let sl = (state.shape === 'cube' ? l : l) * PIXEL_SCALE;
                let sw = (state.shape === 'cube' ? l : w) * PIXEL_SCALE;
                let sh = (state.shape === 'cube' ? l : h) * PIXEL_SCALE;

                // Ù…Ø±Ú©Ø² ØµÙ„ÛŒØ¨ (Ú©Ù Ø¬Ø¹Ø¨Ù‡)
                const startX = cx - sl/2;
                const startY = cy - sw/2;

                // Ø±Ø³Ù… Ú©Ù
                ctx.fillRect(startX, startY, sl, sw);
                ctx.strokeRect(startX, startY, sl, sw);

                // Ø±Ø³Ù… Ø¨Ø§Ù„Ø§ (Ø¯ÙˆØ±ØªØ±)
                ctx.fillRect(startX, startY - sh, sl, sh); // Ù¾Ø´Øª
                ctx.strokeRect(startX, startY - sh, sl, sh);
                
                ctx.fillRect(startX, startY - sh - sw, sl, sw); // Ø³Ù‚Ù (Ø¯ÙˆØ±ØªØ±ÛŒÙ†)
                ctx.strokeRect(startX, startY - sh - sw, sl, sw);

                // Ø±Ø³Ù… Ù¾Ø§ÛŒÛŒÙ† (Ø¬Ù„Ùˆ)
                ctx.fillRect(startX, startY + sw, sl, sh);
                ctx.strokeRect(startX, startY + sw, sl, sh);

                // Ø±Ø³Ù… Ú†Ù¾
                ctx.fillRect(startX - sh, startY, sh, sw);
                ctx.strokeRect(startX - sh, startY, sh, sw);

                // Ø±Ø³Ù… Ø±Ø§Ø³Øª
                ctx.fillRect(startX + sl, startY, sh, sw);
                ctx.strokeRect(startX + sl, startY, sh, sw);

            } else if (state.shape === 'cylinder') {
                // Ú¯Ø³ØªØ±Ø¯Ù‡ Ø§Ø³ØªÙˆØ§Ù†Ù‡: ÛŒÚ© Ù…Ø³ØªØ·ÛŒÙ„ Ø¨Ø²Ø±Ú¯ + Ø¯Ùˆ Ø¯Ø§ÛŒØ±Ù‡
                let sr = r * PIXEL_SCALE;
                let sh = h * PIXEL_SCALE;
                let circumference = 2 * Math.PI * sr; // Ø·ÙˆÙ„ Ù…Ø³ØªØ·ÛŒÙ„ Ø¨Ø±Ø§Ø¨Ø± Ù…Ø­ÛŒØ· Ø¯Ø§ÛŒØ±Ù‡

                // Ú†ÙˆÙ† Ù…Ø­ÛŒØ· Ø®ÛŒÙ„ÛŒ Ø¨Ø²Ø±Ú¯ Ù…ÛŒØ´Ù‡ØŒ ÛŒÙ‡ Ú©Ù… Ø§Ø³Ú©ÛŒÙ„ Ø±Ùˆ Ù…ÙˆÙ‚Øª Ú©Ù… Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… Ú©Ù‡ Ø¬Ø§ Ø¨Ø´Ù‡
                let scaleFactor = 0.6; 
                sr *= scaleFactor;
                sh *= scaleFactor;
                circumference *= scaleFactor;

                // Ù…Ø³ØªØ·ÛŒÙ„ Ø¨Ø¯Ù†Ù‡
                const rectX = cx - circumference / 2;
                const rectY = cy - sh / 2;
                
                ctx.fillRect(rectX, rectY, circumference, sh);
                ctx.strokeRect(rectX, rectY, circumference, sh);

                // Ø¯Ø§ÛŒØ±Ù‡ Ø¨Ø§Ù„Ø§
                ctx.beginPath();
                ctx.arc(cx, rectY - sr, sr, 0, 2 * Math.PI);
                ctx.fill(); ctx.stroke();

                // Ø¯Ø§ÛŒØ±Ù‡ Ù¾Ø§ÛŒÛŒÙ†
                ctx.beginPath();
                ctx.arc(cx, rectY + sh + sr, sr, 0, 2 * Math.PI);
                ctx.fill(); ctx.stroke();
                
                // Ù†ÙˆØ´ØªÙ† Ø§Ø¨Ø¹Ø§Ø¯ Ø±ÙˆÛŒ Ø´Ú©Ù„
                ctx.fillStyle = "black";
                ctx.font = "12px Arial";
                ctx.fillText("Ù…Ø­ÛŒØ· = 2Ï€r", cx - 20, rectY + sh/2);
            }
            ctx.restore();
        }

        // Ø´Ø±ÙˆØ¹ Ø§ÙˆÙ„ÛŒÙ‡
        updateCalculations();
        
    </script>
</body>
</html>