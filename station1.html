<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Û±: Ú©Ø§Ø±Ø®Ø§Ù†Ù‡ Ø´Ú©Ù„Ø§Øªâ€ŒØ³Ø§Ø²ÛŒ</title>
    <style>
        :root {
            --chocolate-dark: #3E2723;
            --chocolate-milk: #795548;
            --gold: #FFC107;
            --bg-cream: #F5F5DC;
            --success: #4CAF50;
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-cream);
            color: var(--chocolate-dark);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            color: var(--chocolate-dark);
            border-bottom: 3px solid var(--gold);
            padding-bottom: 10px;
            margin-bottom: 30px;
        }

        /* --- Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø±Ù†Ø§Ù…Ù‡ --- */
        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1000px;
            width: 100%;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(62, 39, 35, 0.2);
            transition: filter 0.3s ease;
        }

        .controls-panel {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border-left: 2px dashed var(--chocolate-milk);
        }

        .visual-panel {
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #fafafa;
            border-radius: 10px;
            padding: 10px;
        }

        canvas {
            border: 1px solid #ddd;
            background: white;
            border-radius: 8px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        select, input[type="range"] {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ccc;
            outline: none;
        }
        
        input[type="range"] {
            cursor: pointer;
        }

        .value-display {
            float: left;
            font-weight: bold;
            color: var(--chocolate-milk);
            font-family: sans-serif;
        }

        .stats-box {
            background: var(--chocolate-dark);
            color: var(--gold);
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            text-align: center;
            min-width: 250px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: border 0.3s;
        }

        .formula {
            font-style: italic;
            font-family: "Times New Roman", serif;
            font-size: 1.4em;
            margin-top: 10px;
            display: block;
            opacity: 0.8;
        }

        .target-box {
            background: #f0f0f0;
            border: 2px solid var(--chocolate-milk);
            padding: 20px;
            margin-top: 30px;
            border-radius: 12px;
            text-align: center;
        }
        
        .target-box h3 { margin: 0 0 10px 0; font-size: 1.1rem; color: #555; }

        .status-message {
            margin-top: 15px;
            font-weight: bold;
            font-size: 1.2em;
            min-height: 30px;
        }

        .success-anim {
            animation: pulse 1s infinite;
            color: var(--success);
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* --- Ø§Ø³ØªØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¯Ø§Ù„ (Ù¾Ù†Ø¬Ø±Ù‡ Ø¯Ø§Ø³ØªØ§Ù†) --- */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--overlay-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            border: 5px solid var(--gold);
            box-shadow: 0 0 30px rgba(255, 193, 7, 0.4);
            animation: slideDown 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .modal-content h2 { color: var(--chocolate-dark); margin-top: 0; }
        .modal-content p { font-size: 1.2em; line-height: 1.8; color: #444; margin-bottom: 25px; }
        
        .start-btn {
            background: var(--chocolate-dark);
            color: white;
            border: none;
            padding: 12px 35px;
            font-size: 1.3em;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .start-btn:hover { 
            background: var(--chocolate-milk); 
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.3);
        }

        @keyframes slideDown {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .hidden { display: none !important; }

        @media (max-width: 800px) {
            .container { flex-direction: column-reverse; }
            .controls-panel { border-left: none; border-top: 2px dashed var(--chocolate-milk); padding-top: 20px;}
        }
    </style>
</head>
<body>

    <div id="introModal" class="modal-overlay">
        <div class="modal-content">
            <h2>ğŸ‘‹ Ø³Ù„Ø§Ù… Ù…Ù‡Ù†Ø¯Ø³ Ø¬Ø¯ÛŒØ¯!</h2>
            <p>Ø¨Ù‡ Ú©Ø§Ø±Ø®Ø§Ù†Ù‡ Ø´Ú©Ù„Ø§Øªâ€ŒØ³Ø§Ø²ÛŒ <strong>ChocoMath</strong> Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒ.</p>
            <p>Ù…Ø§ ÛŒÚ© Ú†Ø§Ù„Ø´ Ø¯Ø§Ø±ÛŒÙ…: Ù…Ø´ØªØ±ÛŒâ€ŒÙ‡Ø§ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ù‡Ù…Ø§Ù† Ù…Ù‚Ø¯Ø§Ø± Ø´Ú©Ù„Ø§ØªÛŒ Ø±Ø§ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡Ù†Ø¯ Ú©Ù‡ Ø³ÙØ§Ø±Ø´ Ø¯Ø§Ø¯Ù‡â€ŒØ§Ù†Ø¯ØŒ Ù†Ù‡ Ú©Ù…ØªØ± Ùˆ Ù†Ù‡ Ø¨ÛŒØ´ØªØ±!</p>
            <p>ÙˆØ¸ÛŒÙÙ‡ Ø´Ù…Ø§ Ø§ÛŒÙ† Ø§Ø³Øª Ú©Ù‡ Ø§Ø¨Ø¹Ø§Ø¯ <strong>Ù‚Ø§Ù„Ø¨ Ø´Ú©Ù„Ø§Øª</strong> Ø±Ø§ Ø·ÙˆØ±ÛŒ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯ Ú©Ù‡ Ø­Ø¬Ù… Ø¢Ù† Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø¨Ø±Ø§Ø¨Ø± Ø¨Ø§ Â«Ø³ÙØ§Ø±Ø´ Ù…Ø´ØªØ±ÛŒÂ» Ø´ÙˆØ¯.</p>
            <button class="start-btn" onclick="startGame()">Ø¢Ù…Ø§Ø¯Ù‡â€ŒØ§Ù…ØŒ Ø´Ø±ÙˆØ¹ Ú©Ù†ÛŒÙ…!</button>
        </div>
    </div>

    <h1>ğŸ­ Ø§ÛŒØ³ØªÚ¯Ø§Ù‡ Û±: Ø·Ø±Ø§Ø­ÛŒ Ù‚Ø§Ù„Ø¨</h1>

    <div class="container" id="mainContainer">
        
        <div class="visual-panel">
            <canvas id="moldCanvas" width="340" height="340"></canvas>
            <div class="stats-box">
                <div>Ø­Ø¬Ù… Ù‚Ø§Ù„Ø¨ Ø´Ù…Ø§:</div>
                <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">
                    <span id="currentVol">0</span> 
                    <span style="font-size:0.4em; opacity:0.8;">cmÂ³</span>
                </div>
                <span id="formulaDisplay" class="formula">V = ...</span>
            </div>
        </div>

        <div class="controls-panel">
            <div class="input-group">
                <label for="shapeSelect">Û±. Ø§Ù†ØªØ®Ø§Ø¨ Ù†ÙˆØ¹ Ù‚Ø§Ù„Ø¨:</label>
                <select id="shapeSelect" onchange="changeShape()">
                    <option value="cube">Ù…Ú©Ø¹Ø¨ (Cube)</option>
                    <option value="rectPrism">Ù…Ú©Ø¹Ø¨ Ù…Ø³ØªØ·ÛŒÙ„ (Prism)</option>
                    <option value="cylinder">Ø§Ø³ØªÙˆØ§Ù†Ù‡ (Cylinder)</option>
                </select>
            </div>

            <div id="slidersContainer">
                </div>

            <div class="target-box">
                <h3>ğŸ“œ Ø³ÙØ§Ø±Ø´ Ù…Ø´ØªØ±ÛŒ (Ù‡Ø¯Ù Ø´Ù…Ø§):</h3>
                <div style="font-size: 2em; font-weight: bold; color: var(--chocolate-dark); margin: 10px 0;">
                    <span id="targetVol">0</span> <span style="font-size:0.5em">cmÂ³</span>
                </div>
                <div id="statusMsg" class="status-message">Ø§Ø¨Ø¹Ø§Ø¯ Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯...</div>
                
                <button onclick="generateNewTarget(true)" 
                        style="margin-top:20px; padding:8px 20px; cursor:pointer; background: #e0e0e0; border:1px solid #bbb; border-radius:50px; font-size:0.9em; transition:0.2s;">
                    ğŸ”„ Ø¯Ø±ÛŒØ§ÙØª Ø³ÙØ§Ø±Ø´ Ø¬Ø¯ÛŒØ¯
                </button>
            </div>
        </div>

    </div>
    <script>
        // ==========================================
        // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ùˆ ÙˆØ¶Ø¹ÛŒØª Ø¨Ø±Ù†Ø§Ù…Ù‡
        // ==========================================
        const state = {
            shape: 'cube',
            dims: { l: 5, w: 5, h: 5, r: 3 }, 
            target: 0,
            // Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø¯Ù‚ÛŒÙ‚ Ø§Ø³Ù„Ø§ÛŒØ¯Ø±Ù‡Ø§ (Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø¨Ø§Ú¯ ØªÙˆÙ„ÛŒØ¯ Ù‡Ø¯Ù Ù†Ø§Ù…Ù…Ú©Ù†)
            limits: { 
                cube: { min: 1, max: 10 },
                rect: { min: 1, max: 10 },
                cyl_r: { min: 1, max: 6 },  // Ù†Ú©ØªÙ‡ Ù…Ù‡Ù…: Ø´Ø¹Ø§Ø¹ Ø­Ø¯Ø§Ú©Ø«Ø± 6 Ø§Ø³Øª
                cyl_h: { min: 1, max: 10 }
            }
        };

        const canvas = document.getElementById('moldCanvas');
        const ctx = canvas.getContext('2d');
        const PIXEL_SCALE = 15; 

        // ==========================================
        // ØªÙˆØ§Ø¨Ø¹ Ø´Ø±ÙˆØ¹ Ùˆ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ
        // ==========================================
        
        // Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ (Ø¨Ø³ØªÙ† Ù…ÙˆØ¯Ø§Ù„)
        function startGame() {
            const modal = document.getElementById('introModal');
            const container = document.getElementById('mainContainer');
            
            modal.style.opacity = '0'; // Ø§Ù†ÛŒÙ…ÛŒØ´Ù† ÙÛŒØ¯ Ø§ÙˆØª
            setTimeout(() => {
                modal.classList.add('hidden');
                container.style.filter = "blur(0)"; // Ø­Ø°Ù ØªØ§Ø±ÛŒ
            }, 300);

            init();
        }

        // Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø§ÙˆÙ„ÛŒÙ‡
        function init() {
            changeShape(); 
        }

        // ØªØ§Ø± Ú©Ø±Ø¯Ù† ØµÙØ­Ù‡ ØªØ§ Ù‚Ø¨Ù„ Ø§Ø² Ø²Ø¯Ù† Ø¯Ú©Ù…Ù‡ Ø´Ø±ÙˆØ¹
        document.getElementById('mainContainer').style.filter = "blur(8px)";


        // ==========================================
        // ØªÙˆØ§Ø¨Ø¹ Ù…Ù†Ø·Ù‚ Ø±ÛŒØ§Ø¶ÛŒ Ùˆ Ù‡Ø¯Ùâ€ŒÚ¯Ø°Ø§Ø±ÛŒ
        // ==========================================

        // ØªÙˆÙ„ÛŒØ¯ Ø¹Ø¯Ø¯ ØªØµØ§Ø¯ÙÛŒ Ú©Ù‡ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø¨Ø§ Ú¯Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ø§Ø³Ù„Ø§ÛŒØ¯Ø± (0.5) Ù‡Ù…Ø§Ù‡Ù†Ú¯ Ø¨Ø§Ø´Ø¯
        function getRandomVal(min, max, step = 0.5) {
            const steps = (max - min) / step;
            const randomStep = Math.floor(Math.random() * (steps + 1));
            return min + (randomStep * step);
        }

        // ØªÙˆÙ„ÛŒØ¯ Ù‡Ø¯Ù (Ø³ÙØ§Ø±Ø´ Ù…Ø´ØªØ±ÛŒ)
        function generateNewTarget(resetDims = false) {
            let targetV = 0;

            if (state.shape === 'cube') {
                const fakeL = getRandomVal(state.limits.cube.min, state.limits.cube.max);
                targetV = Math.pow(fakeL, 3);
            } else if (state.shape === 'rectPrism') {
                const fakeL = getRandomVal(state.limits.rect.min, state.limits.rect.max);
                const fakeW = getRandomVal(state.limits.rect.min, state.limits.rect.max);
                const fakeH = getRandomVal(state.limits.rect.min, state.limits.rect.max);
                targetV = fakeL * fakeW * fakeH;
            } else if (state.shape === 'cylinder') {
                // Ø§ÛŒÙ†Ø¬Ø§ Ø§Ø² Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø®Ø§Øµ Ø§Ø³ØªÙˆØ§Ù†Ù‡ (Ø´Ø¹Ø§Ø¹ ØªØ§ 6) Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…
                const fakeR = getRandomVal(state.limits.cyl_r.min, state.limits.cyl_r.max);
                const fakeH = getRandomVal(state.limits.cyl_h.min, state.limits.cyl_h.max);
                targetV = Math.PI * Math.pow(fakeR, 2) * fakeH;
            }

            state.target = targetV;
            
            // Ù†Ù…Ø§ÛŒØ´ Ù‡Ø¯Ù (Ø§Ú¯Ø± Ø§Ø¹Ø´Ø§Ø±ÛŒ Ø¨ÙˆØ¯ 1 Ø±Ù‚Ù…ØŒ Ø§Ú¯Ø± ØµØ­ÛŒØ­ Ø¨ÙˆØ¯ Ø¨Ø¯ÙˆÙ† Ø§Ø¹Ø´Ø§Ø±)
            let displayTarget = Number.isInteger(targetV) ? targetV : targetV.toFixed(1);
            document.getElementById('targetVol').innerText = displayTarget;

            // Ø±ÛŒØ³Øª Ú©Ø±Ø¯Ù† Ø§Ø³Ù„Ø§ÛŒØ¯Ø±Ù‡Ø§ Ø¨Ù‡ Ù…Ù‚Ø§Ø¯ÛŒØ± Ú©Ù… ØªØ§ Ú©Ø§Ø±Ø¨Ø± Ù…Ø¬Ø¨ÙˆØ± Ø¨Ù‡ ØªÙ„Ø§Ø´ Ø´ÙˆØ¯
            if (resetDims) {
                state.dims = { l: 2, w: 2, h: 2, r: 2 };
                updateSlidersUI();
            }

            checkSuccess();
        }

        // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø­Ø¬Ù… ÙØ¹Ù„ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø§Ø³Ù„Ø§ÛŒØ¯Ø±Ù‡Ø§
        function calculateVolume() {
            let v = 0;
            const { l, w, h, r } = state.dims;

            if (state.shape === 'cube') {
                v = Math.pow(l, 3);
            } else if (state.shape === 'rectPrism') {
                v = l * w * h;
            } else if (state.shape === 'cylinder') {
                v = Math.PI * Math.pow(r, 2) * h;
            }

            // Ù†Ù…Ø§ÛŒØ´ Ø­Ø¬Ù… Ú©Ø§Ø±Ø¨Ø±
            let displayV = Number.isInteger(v) ? v : v.toFixed(1);
            document.getElementById('currentVol').innerText = displayV;
            
            return v; // Ù…Ù‚Ø¯Ø§Ø± Ø¯Ù‚ÛŒÙ‚ Ø±Ø§ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†Ø¯
        }

        // Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ Ù‡Ø¯Ù Ø±Ø³ÛŒØ¯Ù‡ Ø§Ø³ØªØŸ
        function checkSuccess() {
            // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù…Ø¬Ø¯Ø¯ Ø¯Ù‚ÛŒÙ‚
            let currentV = 0;
            const { l, w, h, r } = state.dims;
            if (state.shape === 'cube') currentV = Math.pow(l, 3);
            else if (state.shape === 'rectPrism') currentV = l * w * h;
            else if (state.shape === 'cylinder') currentV = Math.PI * Math.pow(r, 2) * h;

            const diff = Math.abs(currentV - state.target);
            const msg = document.getElementById('statusMsg');
            const box = document.querySelector('.stats-box');
            
            // ØªÙ„ÙˆØ±Ø§Ù†Ø³ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙˆØ§Ù†Ù‡ Ú©Ù…ÛŒ Ø¨ÛŒØ´ØªØ± Ø§Ø³Øª (Ø¨Ù‡ Ø®Ø§Ø·Ø± Ø§Ø¹Ø´Ø§Ø± Ù¾ÛŒ)
            const tolerance = (state.shape === 'cylinder') ? 0.15 : 0.01;

            if (diff <= tolerance) {
                msg.innerText = "Ø¢ÙØ±ÛŒÙ†! Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ø§Ù†Ø¯Ø§Ø²Ù‡ Ø´Ø¯ âœ…";
                msg.className = "status-message success-anim";
                box.style.border = "3px solid #4CAF50";
                box.style.backgroundColor = "#2E7D32"; // Ø³Ø¨Ø² ØªÛŒØ±Ù‡â€ŒØªØ± Ø¨Ø±Ø§ÛŒ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
            } else {
                // Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ Ú©Ø§Ø±Ø¨Ø±
                if (currentV < state.target) msg.innerText = "Ø¨Ø§ÛŒØ¯ Ø¨Ø²Ø±Ú¯ØªØ±Ø´ Ú©Ù†ÛŒ... â¬†ï¸";
                else msg.innerText = "Ø¨Ø§ÛŒØ¯ Ú©ÙˆÚ†Ú©ØªØ±Ø´ Ú©Ù†ÛŒ... â¬‡ï¸";
                
                msg.className = "status-message";
                box.style.border = "none";
                box.style.backgroundColor = "var(--chocolate-dark)"; // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ø±Ù†Ú¯ Ø§ØµÙ„ÛŒ
            }
        }

        // ==========================================
        // ØªÙˆØ§Ø¨Ø¹ Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ (UI)
        // ==========================================

        function changeShape() {
            state.shape = document.getElementById('shapeSelect').value;
            const container = document.getElementById('slidersContainer');
            container.innerHTML = '';
            const formulaDisplay = document.getElementById('formulaDisplay');

            // ØªÙ†Ø¸ÛŒÙ… Ø§Ø³Ù„Ø§ÛŒØ¯Ø±Ù‡Ø§ Ø¨Ø± Ø§Ø³Ø§Ø³ Ø´Ú©Ù„
            if (state.shape === 'cube') {
                state.dims.l = 5; 
                createSlider(container, 'Ø·ÙˆÙ„ Ø¶Ù„Ø¹ (a)', 'l', state.limits.cube.min, state.limits.cube.max, state.dims.l);
                formulaDisplay.innerHTML = "V = aÂ³";
            } else if (state.shape === 'rectPrism') {
                state.dims.l = 5; state.dims.w = 4; state.dims.h = 3;
                createSlider(container, 'Ø·ÙˆÙ„ (l)', 'l', state.limits.rect.min, state.limits.rect.max, state.dims.l);
                createSlider(container, 'Ø¹Ø±Ø¶ (w)', 'w', state.limits.rect.min, state.limits.rect.max, state.dims.w);
                createSlider(container, 'Ø§Ø±ØªÙØ§Ø¹ (h)', 'h', state.limits.rect.min, state.limits.rect.max, state.dims.h);
                formulaDisplay.innerHTML = "V = l Ã— w Ã— h";
            } else if (state.shape === 'cylinder') {
                state.dims.r = 3; state.dims.h = 6;
                // Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø­Ø¯ÙˆØ¯ ØªØ¹Ø±ÛŒÙ Ø´Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙˆØ§Ù†Ù‡
                createSlider(container, 'Ø´Ø¹Ø§Ø¹ (r)', 'r', state.limits.cyl_r.min, state.limits.cyl_r.max, state.dims.r);
                createSlider(container, 'Ø§Ø±ØªÙØ§Ø¹ (h)', 'h', state.limits.cyl_h.min, state.limits.cyl_h.max, state.dims.h);
                formulaDisplay.innerHTML = "V = Ï€ Ã— rÂ² Ã— h";
            }
            
            // ØªÙˆÙ„ÛŒØ¯ Ù‡Ø¯Ù Ø¬Ø¯ÛŒØ¯ Ù…ØªÙ†Ø§Ø³Ø¨ Ø¨Ø§ Ø´Ú©Ù„ Ø¬Ø¯ÛŒØ¯
            generateNewTarget(false);
            calculateVolume();
            draw();
        }

        function createSlider(parent, labelText, param, min, max, val) {
            const div = document.createElement('div');
            div.className = 'input-group';
            div.innerHTML = `
                <label>${labelText} <span class="value-display" id="val-${param}">${val}</span> cm</label>
                <input type="range" min="${min}" max="${max}" step="0.5" value="${val}" 
                    oninput="updateDim('${param}', this.value)">
            `;
            parent.appendChild(div);
        }

        function updateDim(param, value) {
            state.dims[param] = parseFloat(value);
            document.getElementById(`val-${param}`).innerText = value;
            calculateVolume();
            draw();
            checkSuccess();
        }

        function updateSlidersUI() {
            const inputs = document.querySelectorAll('#slidersContainer input');
            inputs.forEach(input => {
                const param = input.getAttribute('oninput').match(/'(\w+)'/)[1];
                if (state.dims[param] !== undefined) {
                    input.value = state.dims[param];
                    document.getElementById(`val-${param}`).innerText = state.dims[param];
                }
            });
            calculateVolume();
            draw();
        }

        // ==========================================
        // ØªÙˆØ§Ø¨Ø¹ Ø±Ø³Ù… (Canvas)
        // ==========================================

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            
            // Ù…Ø±Ú©Ø² Ø¨ÙˆÙ…
            const cx = canvas.width / 2;
            const cy = canvas.height / 2 + 60; // Ú©Ù…ÛŒ Ù¾Ø§ÛŒÛŒÙ† Ù…ÛŒâ€ŒØ¢ÙˆØ±ÛŒÙ… ØªØ§ Ø¬Ø§ Ø¨Ø±Ø§ÛŒ Ø§Ø±ØªÙØ§Ø¹ Ø¨Ø§Ø´Ø¯

            ctx.strokeStyle = '#3E2723';
            ctx.lineWidth = 2.5;
            ctx.fillStyle = 'rgba(121, 85, 72, 0.35)'; // Ø±Ù†Ú¯ Ø¨Ø¯Ù†Ù‡ Ù†ÛŒÙ…Ù‡ Ø´ÙØ§Ù

            const { l, w, h, r } = state.dims;
            
            if (state.shape === 'cube' || state.shape === 'rectPrism') {
                let sl = (state.shape === 'cube' ? l : l) * PIXEL_SCALE;
                let sw = (state.shape === 'cube' ? l : w) * PIXEL_SCALE;
                let sh = (state.shape === 'cube' ? l : h) * PIXEL_SCALE;

                // ØªØ±Ø³ÛŒÙ… Ù†Ù…Ø§ÛŒ Ø§ÛŒØ²ÙˆÙ…ØªØ±ÛŒÚ©
                // ÙˆØ¬Ù‡ Ø¬Ù„Ùˆ
                ctx.beginPath();
                ctx.moveTo(cx - sl/2, cy);
                ctx.lineTo(cx + sl/2, cy);
                ctx.lineTo(cx + sl/2, cy - sh);
                ctx.lineTo(cx - sl/2, cy - sh);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();

                // ÙˆØ¬Ù‡ Ø¨Ø§Ù„Ø§ (Ø³Ù‚Ù)
                ctx.beginPath();
                ctx.moveTo(cx - sl/2, cy - sh);
                ctx.lineTo(cx + sl/2, cy - sh);
                ctx.lineTo(cx + sl/2 + sw/2, cy - sh - sw/2);
                ctx.lineTo(cx - sl/2 + sw/2, cy - sh - sw/2);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();

                // ÙˆØ¬Ù‡ Ø±Ø§Ø³Øª (Ù¾Ù‡Ù„Ùˆ)
                ctx.beginPath();
                ctx.moveTo(cx + sl/2, cy);
                ctx.lineTo(cx + sl/2 + sw/2, cy - sw/2);
                ctx.lineTo(cx + sl/2 + sw/2, cy - sh - sw/2);
                ctx.lineTo(cx + sl/2, cy - sh);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();

            } else if (state.shape === 'cylinder') {
                let sr = r * PIXEL_SCALE;
                let sh = h * PIXEL_SCALE;

                // Ø¨ÛŒØ¶ÛŒ Ø¨Ø§Ù„Ø§
                ctx.beginPath();
                ctx.ellipse(cx, cy - sh, sr, sr * 0.4, 0, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.fillStyle = 'rgba(121, 85, 72, 0.5)'; // Ø¨Ø§Ù„Ø§ÛŒ Ø§Ø³ØªÙˆØ§Ù†Ù‡ ØªÛŒØ±Ù‡â€ŒØªØ±
                ctx.fill();

                // Ø¨Ø¯Ù†Ù‡ Ø§Ø³ØªÙˆØ§Ù†Ù‡ (Ø§ÙˆÙ„ Ù¾Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… ØªØ§ Ø®Ø·â€ŒÚ†ÛŒÙ†â€ŒÙ‡Ø§ Ù¾ÙˆØ´ÛŒØ¯Ù‡ Ø´ÙˆÙ†Ø¯)
                ctx.fillStyle = 'rgba(121, 85, 72, 0.35)';
                ctx.beginPath();
                ctx.moveTo(cx - sr, cy - sh);
                ctx.lineTo(cx + sr, cy - sh);
                ctx.lineTo(cx + sr, cy);
                // Ù…Ù†Ø­Ù†ÛŒ Ù¾Ø§ÛŒÛŒÙ† Ø¨Ø¯Ù†Ù‡
                ctx.ellipse(cx, cy, sr, sr * 0.4, 0, 0, Math.PI, false); 
                ctx.lineTo(cx - sr, cy - sh);
                ctx.fill();

                // Ø®Ø·ÙˆØ· Ú©Ù†Ø§Ø±ÛŒ
                ctx.beginPath();
                ctx.moveTo(cx - sr, cy - sh);
                ctx.lineTo(cx - sr, cy);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(cx + sr, cy - sh);
                ctx.lineTo(cx + sr, cy);
                ctx.stroke();

                // Ø®Ø· Ù…Ù†Ø­Ù†ÛŒ Ù¾Ø§ÛŒÛŒÙ† (Ø¬Ù„Ùˆ)
                ctx.beginPath();
                ctx.ellipse(cx, cy, sr, sr * 0.4, 0, 0, Math.PI); 
                ctx.stroke();

                // Ø®Ø· Ù…Ù†Ø­Ù†ÛŒ Ù¾Ø§ÛŒÛŒÙ† (Ù¾Ø´Øª - Ø®Ø· Ú†ÛŒÙ†)
                ctx.beginPath();
                ctx.setLineDash([5, 5]);
                ctx.ellipse(cx, cy, sr, sr * 0.4, 0, Math.PI, 2 * Math.PI);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            ctx.restore();
        }
    </script>
</body>
</html>